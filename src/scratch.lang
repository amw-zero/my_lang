schema Server
  comments: [Int]
  
  def hey
    x + 5
  end
end

# 
action MultiModel(rt: RecurringTransaction, d: Date) do
  rt.comments.add("New comment #{d.to_s}")
end


check do
  all? do |t: Transaction|
    t.hey == 5
  end
end

schema Application do
  comments: [String]
  
  def add_comment(comment: String)
    comments.push(comment)
  end
end

# Creating 2 versions of state and methods 
refinement Fullstack do |schema|
  def client_attribute_def(attr)
    "client_#{attribute.name}: #{attribute.type}"
  end

  def call_server

  def client_method_def(method)
    quote do
      def client_#{method.name}(#{method.arguments})
        
      end
    end
  end

  quote do
    schema Fullstack#{schema.name} do  
      *#{schema.body.definitions.map do |definition|
        case attribute
        when SchemaAttribute
          [definition, client_attribute_def(definition)]
        when SchemaMethod
          [definition, client_method_def(definition)]
        end
      end.flatten.join("\n")}
    end
  end
end

# Outputs:

schema FullstackApplication do
  comments: [String]
  client_comments: [String]

  def add_comment(comment: String)
    comments.push(comment)
  end

  def client_add_comment
end

# Creating two different schemas:
refinement ClientServer do |schema|
  def client_attribute_def(attr)
    "client_#{attribute.name}: #{attribute.type}"
  end

  quote do
    [
      #{schema},
      schema "Fullstack#{schema.name}" do

      end
    ]

    schema #{"Fullstack#{schema.name}"} do  
      *#{schema.body.definitions.map do |definition|
        case attribute
        when SchemaAttribute
          [definition, client_attribute_def(definition)]
        when SchemaMethod
          [definition, client_method_def(definition)]
        end
      end.flatten.join("\n")}
    end
  end
end

FullstackApplication = Fullstack(Application)

Client, Server = ClientServer(Application)

Ast:
schema(
  attributes(
    [
      attribute(
        identifier(
          "comments",
          type("String")
        )
      )
    ]
  ),
  functions(
    [

    ]
  )
)


refinement FullStack do

end

client, server = FullStack(Application)
client.add("test")

refinement FullstackApplication(Application) do |application|
  split_state([application.comments])
end

# new state space = { comments: [String], client_comments: [String] }
refinement FullstackApplication(Application) do
  state_space' = state_space X client_comments: [String]

  def server(endpoint: Endpoint, fn: StateTransformer)
    case endpoint do
    AddComment => fn()
      
    end
  end

  add_comment' = server
end


schema Server do
  comments: [String]

  def hey
    test.method(5)
  end
  
  def add(comment: String, d: Int)
    5 + 5 
  end
end

schema Next do
  x: Int
  y: Int
  z: Int
end