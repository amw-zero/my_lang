schema RecurrenceRule = Monthly | Weekly

schema RecurringTransaction do
  amount: Numeric
  name: String
  recurrence_rule: RecurrenceRule
end

schema Scenario do
  name: String
  recurring_transactions: [RecurringTransaction]
end

schema Transaction do
  date: Date
end

# Language hints for architectural differences, i.e. query vs. precomputed data:

schema RecurringTransaction:
  amount: Numeric
  name: String
end

schema Application:
  recurring_transactions: [RecurringTransaction]

  def create_recurring_transaction(rt: RecurringTransaction)
    recurring_transactions.create!(rt)
  end

  def complicated_logic()
    # .precomputed here means that whenever the state changes, this gets set. Can identify
    # the re-cache trigger from all state transitions on this state var.
    recurring_transactions.where { |rt| rt > 5 }.order { |rt| rt.amount }.precomputed
  end
end

# Experimental
# Metaprogramming - function bodies can be referred to via *_def
Application
  .complicated_logic_def
  .precompute

# state vars can be referred to
Application.state_vars.except(:something)


# Schema-level constraints?

schema RecurringTransaction:
  amount: Numeric
  name: String

  amount > 15
  name.length < 100
end

# Distinguish between state machines / data?

# Probably want a way to distinguish between functions, state functions, and state transitions
schema Application do
  recurring_transactions: [RecurringTransaction]
  scenarios: [Scenario]
  
  def add(rt: RecurringTransaction)
    recurring_transactions.add(rt)
  end

  def remove(rt: RecurringTransaction)
    recurring_transactions.delete(rt)
  end

  def update(rt: RecurringTransaction)
    recurring_transactions.update(rt)
  end

  def add_scenario(s: Scenario)
    scenarios.add(s)
  end

  def view_transactions(date_filter: DateFilter)
    recurring_transactions
      .expand
      .select((rt) =>  rt.)
  end
end




schema Server
  comments: [Int]
  
  def hey
    x + 5
  end
end

# 
action MultiModel(rt: RecurringTransaction, d: Date) do
  rt.comments.add("New comment #{d.to_s}")
end


check do
  all? do |t: Transaction|
    t.hey == 5
  end
end

schema Application do
  comments: [String]
  
  def add_comment(comment: String)
    comments.push(comment)
  end
end

# Creating 2 versions of state and methods 
refinement Fullstack do |schema|
  def client_attribute_def(attr)
    "client_#{attribute.name}: #{attribute.type}"
  end

  def call_server

  def client_method_def(method)
    quote do
      def client_#{method.name}(#{method.arguments})
        
      end
    end
  end

  quote do
    schema Fullstack#{schema.name} do  
      *#{schema.body.definitions.map do |definition|
        case attribute
        when SchemaAttribute
          [definition, client_attribute_def(definition)]
        when SchemaMethod
          [definition, client_method_def(definition)]
        end
      end.flatten.join("\n")}
    end
  end
end

# Outputs:

schema FullstackApplication do
  comments: [String]
  client_comments: [String]

  def add_comment(comment: String)
    comments.push(comment)
  end

  def client_add_comment
end

# Creating two different schemas:
refinement ClientServer do |schema|
  def client_attribute_def(attr)
    "client_#{attribute.name}: #{attribute.type}"
  end

  quote do
    [
      #{schema},
      schema "Fullstack#{schema.name}" do

      end
    ]

    schema #{"Fullstack#{schema.name}"} do  
      *#{schema.body.definitions.map do |definition|
        case attribute
        when SchemaAttribute
          [definition, client_attribute_def(definition)]
        when SchemaMethod
          [definition, client_method_def(definition)]
        end
      end.flatten.join("\n")}
    end
  end
end

FullstackApplication = Fullstack(Application)

Client, Server = ClientServer(Application)

Ast:
schema(
  attributes(
    [
      attribute(
        identifier(
          "comments",
          type("String")
        )
      )
    ]
  ),
  functions(
    [

    ]
  )
)


refinement FullStack do

end

client, server = FullStack(Application)
client.add("test")

refinement FullstackApplication(Application) do |application|
  split_state([application.comments])
end

# new state space = { comments: [String], client_comments: [String] }
refinement FullstackApplication(Application) do
  state_space' = state_space X client_comments: [String]

  def server(endpoint: Endpoint, fn: StateTransformer)
    case endpoint do
    AddComment => fn()
      
    end
  end

  add_comment' = server
end


schema Server do
  comments: [String]

  def hey
    test.method(5)
  end
  
  def add(comment: String, d: Int)
    5 + 5 
  end
end

schema Next do
  x: Int
  y: Int
  z: Int
end